#pragma kernel RawIDMask
#pragma kernel RawIDTexture
#pragma kernel CheckIDLayerEdge
#pragma kernel IDLayerExtend
#pragma kernel DoubleLayersBlend
#pragma kernel ThreeLayersBlend

uint3 _TerrainParams;
#define _LayerIndex _TerrainParams.x // 当前地形层的索引
#define _Resolution _TerrainParams.y // 地形Blend贴图的分辨率
#define _LayerCount _TerrainParams.z // 地形层数
float4 _ExtendParams;

Texture2D<float> _AlphaTexture;
Texture2D<float4> _RawIDTexture;
Texture2D<float4> _SecondLayerExtend;
Texture2D<float4> _ThirdLayerExtend;
StructuredBuffer<uint> _IndexRank;

Texture2DArray<float4> _RawIDMaskArray;
Texture2DArray<float> _AlphaTextureArray;

RWTexture2D<float4> IDResult;
RWTexture2D<float4> BlendResult;

static const int2 _Offset[8] = 
{
    int2(-1, 1),  int2(0, 1),  int2(1, 1),
    int2(-1, 0),               int2(1, 0),
    int2(-1, -1), int2(0, -1), int2(1, -1), 
};
float Encode(uint layerIndex)
{
    return ((float)layerIndex + 1.0) * 0.03125;
}
int Decode(float idValue)
{
    return floor(idValue * 32) - 1;
}
uint2 GetNearID(uint2 id, uint index)
{
    return clamp(id + _Offset[index], 0, _Resolution - 1);
}

[numthreads(8, 8, 1)]
void RawIDMask (uint3 id : SV_DispatchThreadID)
{
    // R：用来保存当前的ID数据，同时向外扩展一个ID(Alpha > 0.1)；
    // G：当前是否为单层，如果当前像素混合值是1并且与周围的混合值相差不大时，那么当前的像素为单层结果，否则为多层结果；
    // B：如果当前像素和周围像素差值过大的时候, 标记出坐标
    float centerAlpha = _AlphaTexture[id.xy];
    bool signID = centerAlpha > 0;
    bool singleLayer = centerAlpha == 1;
    for (uint i = 0; i < 8; i++)
    {
        float nearAlpha = _AlphaTexture[GetNearID(id.xy, i)];
        if (!signID && nearAlpha > 0)
            signID = true;
        if (singleLayer && (centerAlpha - nearAlpha > 0.6))
            singleLayer = false;
    }
    float idValue = signID ? Encode(_LayerIndex) : 0;
    IDResult[id.xy] = float4(idValue, singleLayer ? 1 : 0, 0, 1);
}

// 输出未处理的IDTexutre
[numthreads(8, 8, 1)]
void RawIDTexture (uint3 id : SV_DispatchThreadID)
{
    // 生成初始的IDTexture
    uint validLayerCount = 0;
    float3 idsVlaue = 0;
    bool isSingleLayer = false;
    for (uint i = 0; i < _LayerCount; i++)
    {
        uint3 texID = uint3(id.xy, _IndexRank[i]);
        float4 rawIDMask = _RawIDMaskArray[texID];
        isSingleLayer = isSingleLayer || rawIDMask.g == 1;
        if (rawIDMask.r == 0) continue;
        validLayerCount += 1;
        if (validLayerCount == 1) idsVlaue.x = rawIDMask.r;
        if (validLayerCount == 2) idsVlaue.y = rawIDMask.r;
        if (validLayerCount == 3) idsVlaue.z = rawIDMask.r;
    }
    if (validLayerCount == 1 && !isSingleLayer)
    {
        validLayerCount = 2;
        idsVlaue.y = idsVlaue.x;
    }
    float layerMask = min(3.0, validLayerCount - 1) / 3.0;
    IDResult[id.xy] = float4(idsVlaue, layerMask);
}
bool DistinguishHierarchy(uint layersCount, float mask)
{
    uint tempLayersCount = 1;
    if (mask == 0) tempLayersCount = 1;
    else if (mask == 1) tempLayersCount = 4;
    else if (mask < 0.5) tempLayersCount = 2;
    else if (mask > 0.5) tempLayersCount = 3;
    return layersCount == tempLayersCount;
}
// 检查n层区域内的边缘处交接处, 将混合权限差距过大的位置进行优化(混合值小的变成单层)
// TODO: 测试多种情况: 变成单层只适合差值过大的情况
[numthreads(8, 8, 1)]
void CheckIDLayerEdge (uint3 id : SV_DispatchThreadID)
{
    float4 rawIDValue = _RawIDTexture[id.xy];
    float  centerIDValue = dot(_ExtendParams.xyz, rawIDValue.xyz);
    if (DistinguishHierarchy(_ExtendParams.w, rawIDValue.a))
    {
        uint3 texID = uint3(id.xy, Decode(centerIDValue));
        float centerAlpha = _AlphaTextureArray[texID];
        for (uint i = 0; i < 8; i++)
        {
            float4 nearRawIDValue = _RawIDTexture[GetNearID(id.xy, i)];
            float  nearIDValue = dot(_ExtendParams.xyz, nearRawIDValue.xyz);
            if (!DistinguishHierarchy(_ExtendParams.w, nearRawIDValue.a)
                || Decode(centerIDValue) == Decode(nearIDValue)) continue;
            texID = uint3(GetNearID(id.xy, i), Decode(nearIDValue));
            float nearAlpha = _AlphaTextureArray[texID];
            if ((nearAlpha - centerAlpha) > 0.8)
                rawIDValue.a = (_ExtendParams.w - 1) / 3.0;
        }
    }
    IDResult[id.xy] = rawIDValue;
}

// 扩展一层ID, 给n层混合作为采样的参考
[numthreads(8, 8, 1)]
void IDLayerExtend (uint3 id : SV_DispatchThreadID)
{
    float4 rawIDValue = _RawIDTexture[id.xy];
    float  centerIDValue = dot(_ExtendParams.xyz, rawIDValue.xyz);
    if (DistinguishHierarchy(_ExtendParams.w, rawIDValue.a))
        IDResult[id.xy] = float4(centerIDValue, 0, 0, 1);
    else
    {
        // 当前不是n层的区域, 查找是否有n层的存在
        float4 rawIDResult = -1;
        float3 nearAlphas = 0;
        for (uint i = 0; i < 8; i++)
        {
            float4 nearRawIDValue = _RawIDTexture[GetNearID(id.xy, i)];
            float  nearIDValue = dot(_ExtendParams.xyz, nearRawIDValue.xyz);
            uint3  texID = uint3(GetNearID(id.xy, i), Decode(nearIDValue));
            float  nearAlpha = _AlphaTextureArray[texID];
            if (DistinguishHierarchy(_ExtendParams.w, nearRawIDValue.a))
            {
                rawIDResult.w = 0.25;
                if (rawIDResult.x == -1)
                {
                    rawIDResult.x = nearIDValue;
                    nearAlphas.x = nearAlpha;
                }
                if (rawIDResult.x == nearIDValue) continue;

                if (rawIDResult.y == -1)
                {
                    rawIDResult.y = nearIDValue;
                    nearAlphas.y = nearAlpha;
                }
                if (rawIDResult.y == nearIDValue) continue;

                if (rawIDResult.z == -1)
                {
                    rawIDResult.z = nearIDValue;
                    nearAlphas.z = nearAlpha;
                }
                if (rawIDResult.z == nearIDValue) break;
            }
        }
        // 对混合值大小进行排序
        float3 tempIDResult = rawIDResult.xyz;
        float3 tempAlphas = 0;
        if (rawIDResult.y != -1)
        {
            if (nearAlphas.x < nearAlphas.y)
            {
                tempIDResult.xy = rawIDResult.yx;
                tempAlphas.xy = nearAlphas.yx;
            }
            else
            {
                tempIDResult.xy = rawIDResult.xy;
                tempAlphas.xy = nearAlphas.xy;
            }
            if (rawIDResult.z != -1)
            {
                if (nearAlphas.z > tempAlphas.x)
                    tempIDResult = float3(rawIDResult.z, tempIDResult.xy);
                else if (nearAlphas.z < tempAlphas.y)
                    tempIDResult = float3(tempIDResult.xy, rawIDResult.z);
                else
                    tempIDResult = float3(tempIDResult.x, rawIDResult.z, tempIDResult.y);
            }
        }
        IDResult[id.xy] = float4(tempIDResult.xyz, max(0, rawIDResult.w));
    }
}

[numthreads(8, 8, 1)]
void DoubleLayersBlend (uint3 id : SV_DispatchThreadID)
{
    // ID Map
    float4 rawIDValue = _RawIDTexture[id.xy];
    if (DistinguishHierarchy(2, rawIDValue.a))
    {
        for (uint i = 0; i < 8; i++)
        {
            float4 nearSecondLayerValue = _SecondLayerExtend[GetNearID(id.xy, i)];
            int secondID = Decode(nearSecondLayerValue.y);
            if (secondID > -1)
            {
                int firstID = Decode(nearSecondLayerValue.x);
                float nearFirstAlpha = _AlphaTextureArray[uint3(GetNearID(id.xy, i), firstID)];
                float nearSecondAlpha = _AlphaTextureArray[uint3(GetNearID(id.xy, i), secondID)];
                if (nearFirstAlpha - nearSecondAlpha > 0.8)
                    rawIDValue.a = rawIDValue.y == nearSecondLayerValue.y ? 0 : rawIDValue.a;
                //TODO: 扩展, 这里只是处理了两层之间边缘值之差过大的问题, 如果相差不大并且恰好能感觉出来如何处理
                // int thirdID = Decode(nearSecondLayerValue.z);
            }
        }
    }
    IDResult[id.xy] = rawIDValue;
    // Blend Map
    float4 secondLayerValue = _SecondLayerExtend[id.xy];
    float  doubleAreaAlpha = 0;
    if (secondLayerValue.a != 0)
    {
        uint3 texID = uint3(id.xy, Decode(secondLayerValue.x));
        doubleAreaAlpha = _AlphaTextureArray[texID];
    }
    BlendResult[id.xy] = float4(doubleAreaAlpha, 0, 0, 1);
}

[numthreads(8, 8, 1)]
void ThreeLayersBlend (uint3 id : SV_DispatchThreadID)
{
    float4 secondLayerValue = _SecondLayerExtend[id.xy];
    float4 thirdLayerValue = _ThirdLayerExtend[id.xy];
    float2 threeAreaAlpha = 0;
    uint3 texID = 0;
    if (secondLayerValue.a != 0)
    {
        texID = uint3(id.xy, Decode(secondLayerValue.x));
        threeAreaAlpha.x = _AlphaTextureArray[texID];
    }
    if (thirdLayerValue.a != 0)
    {
        texID = uint3(id.xy, Decode(thirdLayerValue.x));
        threeAreaAlpha.y = _AlphaTextureArray[texID];
    }
    BlendResult[id.xy] = float4(_RawIDTexture[id.xy].r, threeAreaAlpha, 1);
}
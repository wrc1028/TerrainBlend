// 混合
#pragma kernel RawIDTexture
#pragma kernel CheckIDLayerEdge
#pragma kernel IDLayerExtend
#pragma kernel DoubleLayersBlend
#pragma kernel ThreeLayersBlend

uint3 _TerrainParams;
#define _LayerCount _TerrainParams.x // 地形层数
#define _Resolution _TerrainParams.y // 地形Blend贴图的分辨率
#define _LayerIndex _TerrainParams.z
float4 _ExtendParams;

Texture2D<float> _AlphaTexture;
Texture2D<float4> _RawIDTexture;
// Texture2D<float4> _RawIDTextureMask;
Texture2D<float4> _SecondLayerExtend;
Texture2D<float4> _ThirdLayerExtend;
Texture2D<float4> _TempBlendTexture;
StructuredBuffer<uint> _IndexRank;

Texture2DArray<float4> _RawIDMaskArray;
Texture2DArray<float> _AlphaTextureArray;

RWTexture2D<float4> IDResult;
// RWTexture2D<float4> IDResultMask;
RWTexture2D<float4> BlendResult;

static const int2 _Offset[8] = 
{
    int2(-1, 1),  int2(0, 1),  int2(1, 1),
    int2(-1, 0),               int2(1, 0),
    int2(-1, -1), int2(0, -1), int2(1, -1), 
};
static const int2 _CrossOffset[4] = 
{
    int2(0, 1), int2(-1, 0), int2(1, 0), int2(0, -1),
};
float Encode(uint layerIndex, int addTag)
{
    return ((layerIndex << 4) + addTag) / 255.0;
}
int Decode(float idValue)
{
    int tempID = floor(idValue * 255.0);
    return tempID >> 4;
}
int2 DecodeMask(float idValue)
{
    int tempID = floor(idValue * 255.0);
    int layerIndex = tempID >> 4;
    return int2(layerIndex, tempID - layerIndex * 16);
}
uint2 GetNearID(uint2 id, uint index)
{
    return clamp(id + _Offset[index], 0, _Resolution - 1);
}
uint2 GetNeraID(uint2 id, int2 offset)
{
    return clamp(id + offset, 0, _Resolution - 1);
}
uint2 GetCrossID(uint2 id, uint index)
{
    return clamp(id + _CrossOffset[index], 0, _Resolution - 1);
}
// 利用RawIDMask算出新的遮罩(集中在多层中的过渡)
// 利用遮罩对边缘除
// 输出未处理的IDTexutre
[numthreads(8, 8, 1)]
void RawIDTexture (uint3 id : SV_DispatchThreadID)
{
    // 生成初始的IDTexture
    uint  validLayerCount = 0;
    uint3 layersIndex = 0;
    bool isSingleLayer = false;
    for (uint i = 0; i < _LayerCount; i++)
    {
        uint3 texID = uint3(id.xy, _IndexRank[i]);
        float4 rawIDMask = _RawIDMaskArray[texID];
        isSingleLayer = isSingleLayer || rawIDMask.g == 1;
        if (rawIDMask.r == 0) continue;
        validLayerCount += 1;
        if (validLayerCount == 1) layersIndex.x = _IndexRank[i];
        if (validLayerCount == 2) layersIndex.y = _IndexRank[i];
        if (validLayerCount == 3) layersIndex.z = _IndexRank[i];
    }
    // 单层 ==> 多层
    if (validLayerCount == 1 && !isSingleLayer)
    {
        validLayerCount = 2;
        layersIndex.y = layersIndex.x;
    }

    // RGB: 标记是否参与混合以及ID, A 000双层000单层
    float3 idsValue = float3(Encode(layersIndex.x, 1), Encode(layersIndex.y, 1), Encode(layersIndex.z, 1));
    float  layerMask = validLayerCount == 1 ? 1 : (validLayerCount == 2 ? 16 : 0);
    IDResult[id.xy] = float4(idsValue, layerMask / 255.0);
}
bool DistinguishHierarchy(uint layersCount, float mask)
{
    uint2 layeMask = DecodeMask(mask);
    if (layeMask.x == 1) return layersCount == 2;
    else if (layeMask.y == 1) return layersCount == 1;
    else return layersCount == 3;
}
// 检查n层区域内的边缘处交接处, 将混合权限差距过大的位置进行优化(层数下降一个等级)
[numthreads(8, 8, 1)]
void CheckIDLayerEdge (uint3 id : SV_DispatchThreadID)
{
    float4 rawIDValue = _RawIDTexture[id.xy];
    float  centerIDValue = dot(_ExtendParams.xyz, rawIDValue.xyz);
    if (DistinguishHierarchy(_ExtendParams.w, rawIDValue.a))
    {
        uint3 texID = uint3(id.xy, Decode(centerIDValue));
        float centerAlpha = _AlphaTextureArray[texID];
        for (uint i = 0; i < 8; i++)
        {
            float4 nearRawIDValue = _RawIDTexture[GetNearID(id.xy, i)];
            float  nearIDValue = dot(_ExtendParams.xyz, nearRawIDValue.xyz);
            if (!DistinguishHierarchy(_ExtendParams.w, nearRawIDValue.a)
                || Decode(centerIDValue) == Decode(nearIDValue)) continue;
            texID = uint3(GetNearID(id.xy, i), Decode(nearIDValue));
            float nearAlpha = _AlphaTextureArray[texID];
            if ((nearAlpha - centerAlpha) > 0.8)
            {
                // 降一个混合维度
                float layerMask = _ExtendParams.w == 2 ? 1 : (_ExtendParams.w == 3 ? 16 : 0);
                rawIDValue.a = layerMask / 255.0;
            }
        }
    }
    IDResult[id.xy] = rawIDValue;
}

// 扩展一层ID, 给n层混合作为采样的参考
[numthreads(8, 8, 1)]
void IDLayerExtend (uint3 id : SV_DispatchThreadID)
{
    float4 rawIDValue = _RawIDTexture[id.xy];
    float  centerIDValue = dot(_ExtendParams.xyz, rawIDValue.xyz);
    if (DistinguishHierarchy(_ExtendParams.w, rawIDValue.a))
        IDResult[id.xy] = float4(centerIDValue, 0, 0, 1);
    else
    {
        // 当前不是n层的区域, 查找是否有n层的存在
        float4 rawIDResult = -1;
        float3 nearAlphas = 0;
        for (uint i = 0; i < 8; i++)
        {
            float4 nearRawIDValue = _RawIDTexture[GetNearID(id.xy, i)];
            float  nearIDValue = dot(_ExtendParams.xyz, nearRawIDValue.xyz);
            uint3  texID = uint3(GetNearID(id.xy, i), Decode(nearIDValue));
            float  nearAlpha = _AlphaTextureArray[texID];
            if (DistinguishHierarchy(_ExtendParams.w, nearRawIDValue.a))
            {
                rawIDResult.w = 0.25;
                if (rawIDResult.x == -1)
                {
                    rawIDResult.x = nearIDValue;
                    nearAlphas.x = nearAlpha;
                }
                if (rawIDResult.x == nearIDValue) continue;

                if (rawIDResult.y == -1)
                {
                    rawIDResult.y = nearIDValue;
                    nearAlphas.y = nearAlpha;
                }
                if (rawIDResult.y == nearIDValue) continue;

                if (rawIDResult.z == -1)
                {
                    rawIDResult.z = nearIDValue;
                    nearAlphas.z = nearAlpha;
                }
                if (rawIDResult.z == nearIDValue) break;
            }
        }
        // 对混合值大小进行排序
        float3 tempIDResult = rawIDResult.xyz;
        float3 tempAlphas = 0;
        if (rawIDResult.y != -1)
        {
            if (nearAlphas.x < nearAlphas.y)
            {
                tempIDResult.xy = rawIDResult.yx;
                tempAlphas.xy = nearAlphas.yx;
            }
            else
            {
                tempIDResult.xy = rawIDResult.xy;
                tempAlphas.xy = nearAlphas.xy;
            }
            if (rawIDResult.z != -1)
            {
                if (nearAlphas.z > tempAlphas.x)
                    tempIDResult = float3(rawIDResult.z, tempIDResult.xy);
                else if (nearAlphas.z < tempAlphas.y)
                    tempIDResult = float3(tempIDResult.xy, rawIDResult.z);
                else
                    tempIDResult = float3(tempIDResult.x, rawIDResult.z, tempIDResult.y);
            }
        }
        IDResult[id.xy] = float4(tempIDResult.xyz, max(0, rawIDResult.w));
    }
}

[numthreads(8, 8, 1)]
void DoubleLayersBlend (uint3 id : SV_DispatchThreadID)
{
    // ID Map
    float4 rawIDValue = _RawIDTexture[id.xy];
    if (DistinguishHierarchy(2, rawIDValue.a))
    {
        for (uint i = 0; i < 8; i++)
        {
            float4 nearSecondLayerValue = _SecondLayerExtend[GetNearID(id.xy, i)];
            int2 secondID = DecodeMask(nearSecondLayerValue.y);
            if (secondID.y == 1)
            {
                int firstID = Decode(nearSecondLayerValue.x);
                float nearFirstAlpha = _AlphaTextureArray[uint3(GetNearID(id.xy, i), firstID)];
                float nearSecondAlpha = _AlphaTextureArray[uint3(GetNearID(id.xy, i), secondID.x)];
                if ((nearFirstAlpha - nearSecondAlpha) > 0.8 && rawIDValue.y == nearSecondLayerValue.y)
                    rawIDValue.r = Encode(Decode(rawIDValue.r), 0);
            }
        }
    }
    IDResult[id.xy] = rawIDValue;
    // Blend Map
    float4 secondLayerValue = _SecondLayerExtend[id.xy];
    float  doubleAreaAlpha = 0;
    if (secondLayerValue.a != 0)
    {
        uint3 texID = uint3(id.xy, Decode(secondLayerValue.x));
        doubleAreaAlpha = _AlphaTextureArray[texID];
    }
    BlendResult[id.xy] = float4(doubleAreaAlpha, 0, 0, 1);
}

[numthreads(8, 8, 1)]
void ThreeLayersBlend (uint3 id : SV_DispatchThreadID)
{
    // ID Map
    float4 rawIDValue = _RawIDTexture[id.xy];
    IDResult[id.xy] = rawIDValue;
    // Blend Map
    float4 secondLayerValue = _SecondLayerExtend[id.xy];
    float4 thirdLayerValue = _ThirdLayerExtend[id.xy];
    float2 threeAreaAlpha = 0;
    uint3 texID = 0;
    if (secondLayerValue.a != 0)
    {
        texID = uint3(id.xy, Decode(secondLayerValue.x));
        threeAreaAlpha.x = _AlphaTextureArray[texID];
    }
    if (thirdLayerValue.a != 0)
    {
        texID = uint3(id.xy, Decode(thirdLayerValue.x));
        threeAreaAlpha.y = _AlphaTextureArray[texID];
    }
    BlendResult[id.xy] = float4(_TempBlendTexture[id.xy].r, threeAreaAlpha, 1);
}
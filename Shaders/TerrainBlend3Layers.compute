#pragma kernel FindTransformMask
#pragma kernel TransformDimension
#pragma kernel FindExtendTransformMask
#pragma kernel TransformExtendDimension
#pragma kernel CombineAlphaMask
#pragma kernel ThreeLayersBlend

#include "TerrainUtils.hlsl"

// 三层混合结构分为
// 1、特殊的三层混合结构, 二层转三层
// 2、原始的三层结构
// 满足Mask的条件: 
// 1、二、三层都存在的ID
// 2、混合值相似的ID
[numthreads(8, 8, 1)] 
void FindTransformMask (uint3 id : SV_DispatchThreadID)
{
    float4 sEdgeMask = _TextureInput01[id.xy];
    float4 tEdgeMask = _TextureInput02[id.xy];
    float4 rawIDValue = _TextureInput03[id.xy];
    float4 alphaMask = 0;
    uint2 idMask = DecodeMask(rawIDValue.r);
    if ((sEdgeMask.a > 0 || tEdgeMask.a > 0))
    {
        for (uint i = 0; i < 8; i++)
        {
            uint2 nearID = GetNearID(id.xy, i);
            float4 nearSEdgeMask = _TextureInput01[nearID];
            float4 nearTEdgeMask = _TextureInput02[nearID];
            float4 nearRawIDValue = _TextureInput03[nearID];
            uint2 nearIDMask = DecodeMask(rawIDValue.r);
            // 再三层结构内操作
            if (nearRawIDValue.a != 0) continue;
            if (nearSEdgeMask.a > 0)
            {
                if (rawIDValue.g == nearRawIDValue.b)
                    alphaMask.r = rawIDValue.g;
                else if (rawIDValue.b == nearRawIDValue.g)
                    alphaMask.r = rawIDValue.b;
            }
            if (nearTEdgeMask.a > 0)
            {
                if (rawIDValue.g == nearRawIDValue.b)
                    alphaMask.g = rawIDValue.g;
                else if (rawIDValue.b == nearRawIDValue.g)
                    alphaMask.g = rawIDValue.b;
            }
            
        }
        alphaMask.b = alphaMask.r > 0 ? 1 : (sEdgeMask.a > 0 ? 0.66 : 0);
        alphaMask.a = alphaMask.g > 0 ? 1 : (tEdgeMask.a > 0 ? 0.66 : 0);
    }
    Result01[id.xy] = alphaMask;
}

// 根据Alpha转移, 对RawIDEdgeTexture进行操作并输出
// 后续对RawIDEdgeTexture进行扩展, 因为涉及
[numthreads(8, 8, 1)]
void TransformDimension (uint3 id : SV_DispatchThreadID)
{
    // GB Mask ==> 0; 
    float4 sEdgeMask = _TextureInput01[id.xy];
    float4 tEdgeMask = _TextureInput02[id.xy];
    float4 alphaMask = _TextureInput03[id.xy];
    float4 rawIDValue = _TextureInput04[id.xy];
    float4 alphaValue = 0;
    bool changeGChannel = false;
    bool changeBChannel = false;
    if (alphaMask.b == 1 && alphaMask.a == 1)
    {
        if (sEdgeMask.r == alphaMask.r)
        {
            alphaValue.r = sEdgeMask.r;
            changeGChannel = true;
        }
        if (tEdgeMask.r == alphaMask.g)
        {
            alphaValue.g = tEdgeMask.r;
            changeBChannel = true;
        }
    }
    else
    {
        if (alphaMask.b == 1 && sEdgeMask.r == alphaMask.r)
        {
            alphaValue.r = sEdgeMask.r;
            changeGChannel = true;
        }
        else if (alphaMask.a == 1 && tEdgeMask.r == alphaMask.g)
        {
            alphaValue.g = tEdgeMask.r;
            changeBChannel = true;
        }
        else
        {
            for (uint i = 0; i < 8; i++)
            {
                uint2 nearID = GetNearID(id.xy, i);
                float4 nearAlphaMask = _TextureInput03[nearID];
                if (nearAlphaMask.a == 0) continue;
                if (sEdgeMask.r == nearAlphaMask.r)
                {
                    alphaValue.r = sEdgeMask.r;
                    changeGChannel = true;
                }
                if (tEdgeMask.r == nearAlphaMask.g)
                {
                    alphaValue.g = tEdgeMask.r;
                    changeBChannel = true;
                }
            }
        }
    }
    
    if (changeGChannel)
    {
        sEdgeMask = 0;
        rawIDValue.g = Encode(Decode(rawIDValue.g), 0);
    }
    if (changeBChannel)
    {
        tEdgeMask = 0;
        rawIDValue.b = Encode(Decode(rawIDValue.b), 0);
    }
    alphaValue.b = alphaValue.r > 0 ? 1 : 0;
    alphaValue.a = alphaValue.g > 0 ? 1 : 0;

    Result01[id.xy] = sEdgeMask;
    Result02[id.xy] = tEdgeMask;
    Result03[id.xy] = rawIDValue;
    Result04[id.xy] = alphaValue;
}

// TODO: 相交的和AlphaMask并不完全重合, 倒是扩展后的二三层是有重合的
[numthreads(8, 8, 1)]
void FindExtendTransformMask (uint3 id : SV_DispatchThreadID)
{
    // Extend: x y z 当前和周围的ID; w: 范围
    // Alpha Mask: RB(GA): 两层都存在的ID和遮罩
    float4 extendLayerS = _TextureInput01[id.xy];
    float4 extendLayerT = _TextureInput02[id.xy];
    float4 alphaMask = _TextureInput03[id.xy];
    float4 alphaResult = 0;
    bool isTransform = false;

    // 相交部分重合的情况: 对比双方是否有相同ID
    if (extendLayerS.y > 0 && extendLayerT.y > 0)
    {
        if (extendLayerS.x == extendLayerT.x || extendLayerS.x == extendLayerT.y)
            alphaResult.rg = extendLayerS.x;
        else if (extendLayerS.y == extendLayerT.x || extendLayerS.y == extendLayerT.y)
            alphaResult.rg = extendLayerS.y;
    }
    // 寻找隔壁是否存在相同ID, 如果有就记录
    else
    {
        bool notFindS = true;
        bool notFindT = true;
        for (uint i = 0; i < 8; i++)
        {
            uint2 nearID = GetNearID(id.xy, i);
            float4 nearExtendLayerS = _TextureInput01[nearID];
            float4 nearExtendLayerT = _TextureInput02[nearID];
            if (extendLayerS.y > 0 && nearExtendLayerT.y > 0)
            {
                if (extendLayerS.x == nearExtendLayerT.x || extendLayerS.x == nearExtendLayerT.y)
                    alphaResult.r = extendLayerS.x;
                else if (extendLayerS.y == nearExtendLayerT.x || extendLayerS.y == nearExtendLayerT.y)
                    alphaResult.r = extendLayerS.y;
                if (alphaResult.r > 0)
                {
                    notFindS = false;
                    break;
                }
            }
            else if (extendLayerT.y > 0 && nearExtendLayerS.y > 0)
            {
                if (extendLayerT.x == nearExtendLayerS.x || extendLayerT.x == nearExtendLayerS.y)
                    alphaResult.g = extendLayerT.x;
                else if (extendLayerT.y == nearExtendLayerS.x || extendLayerT.y == nearExtendLayerS.y)
                    alphaResult.g = extendLayerT.y;
                if (alphaResult.g > 0)
                {
                    notFindT = false;
                    break;
                }
            }
        }
        if (notFindS && extendLayerS.y > 0 && alphaMask.z == 1)
        {
            if (extendLayerS.x == alphaMask.x)
                alphaResult.r = extendLayerS.x;
            else if (extendLayerS.y == alphaMask.x)
                alphaResult.r = extendLayerS.y;
        }
        else if (notFindT && extendLayerT.y > 0 && alphaMask.a == 1)
        {
            if (extendLayerT.x == alphaMask.y)
                alphaResult.g = extendLayerT.x;
            else if (extendLayerT.y == alphaMask.y)
                alphaResult.g = extendLayerT.y;
        }
        else
        {
            for (uint j = 0; j < 8; j++)
            {
                uint2 nearID = GetNearID(id.xy, j);
                float4 nearAlphaMask = _TextureInput03[nearID];
                if (notFindS && extendLayerS.y > 0 && nearAlphaMask.z == 1)
                {
                    if (extendLayerS.x == nearAlphaMask.x)
                        alphaResult.r = extendLayerS.x;
                    else if (extendLayerS.y == nearAlphaMask.x)
                        alphaResult.r = extendLayerS.y;
                }
                if (notFindT && extendLayerT.y > 0 && nearAlphaMask.a == 1)
                {
                    if (extendLayerT.x == nearAlphaMask.y)
                        alphaResult.g = extendLayerT.x;
                    else if (extendLayerT.y == nearAlphaMask.y)
                        alphaResult.g = extendLayerT.y;
                }
            }
        }
        if (notFindS && extendLayerS.y > 0 && alphaResult.r == 0) alphaResult.r = extendLayerS.x;
        if (notFindT && extendLayerT.y > 0 && alphaResult.g == 0) alphaResult.g = extendLayerT.x;
    }

    alphaResult.b = alphaResult.r > 0 ? 1 : 0;
    alphaResult.a = alphaResult.g > 0 ? 1 : 0;

    Result01[id.xy] = alphaResult;
}

// 更改扩展后相交处的AlphaMask
[numthreads(8, 8, 1)]
void TransformExtendDimension (uint3 id : SV_DispatchThreadID)
{
    // Extend: x y z 当前和周围的ID; w: 范围
    float4 extendLayerS = _TextureInput01[id.xy];
    float4 extendLayerT = _TextureInput02[id.xy];
    float4 alphaMaskExtend = _TextureInput03[id.xy];
    float4 rawIDValue = _TextureInput04[id.xy];
    float4 alphaValue = 0;
    // Alpha Mask 周围的ID Mask => 0
    // Alpha 填补ID Mask修改的位置
    // Extend改为非AlphaMask对应的
    if (alphaMaskExtend.z == 1)
    {
        if (extendLayerS.x == alphaMaskExtend.x)
            extendLayerS.x = extendLayerS.y;
    }
    else if (extendLayerS.a > 0)
    {
        for (uint i = 0; i < 8; i++)
        {
            uint2 nearID = GetNearID(id.xy, i);
            float4 nearAlphaMaskExtend = _TextureInput03[nearID];
            if (nearAlphaMaskExtend.z == 0) continue;
            if (extendLayerS.x == nearAlphaMaskExtend.x)
            {
                alphaValue.x = extendLayerS.x;
                rawIDValue.g = Encode(Decode(rawIDValue.g), 0);
            }
        }
    }

    if (alphaMaskExtend.w == 1)
    {
        if (extendLayerT.x == alphaMaskExtend.x)
            extendLayerT.x = extendLayerT.y;
    }
    else if (extendLayerT.a > 0)
    {
        for (uint i = 0; i < 8; i++)
        {
            uint2 nearID = GetNearID(id.xy, i);
            float4 nearAlphaMaskExtend = _TextureInput03[nearID];
            if (nearAlphaMaskExtend.w == 0) continue;
            if (extendLayerT.x == nearAlphaMaskExtend.y)
            {
                alphaValue.y = extendLayerT.x;
                rawIDValue.b = Encode(Decode(rawIDValue.b), 0);
            }
        }
    }

    alphaValue.b = alphaValue.r > 0 ? 1 : 0;
    alphaValue.a = alphaValue.g > 0 ? 1 : 0;

    Result01[id.xy] = extendLayerS;
    Result02[id.xy] = extendLayerT;
    Result03[id.xy] = rawIDValue;
    Result04[id.xy] = alphaValue;
}

// 合并AlphaMask
[numthreads(8, 8, 1)]
void CombineAlphaMask (uint3 id : SV_DispatchThreadID)
{
    float4 alphaMaskEdge = _TextureInput01[id.xy];
    float4 alphaMaskExtend = _TextureInput02[id.xy];
    // 累加就行
    float4 alphaValue = 0;
    if (alphaMaskExtend.z == 1)
        alphaValue.x = alphaMaskExtend.x;
    if (alphaMaskExtend.w == 1)
        alphaValue.x = alphaMaskExtend.y;
    if (alphaMaskEdge.z == 1)
        alphaValue.x = alphaMaskEdge.x;
    if (alphaMaskEdge.w == 1)
        alphaValue.x = alphaMaskEdge.y;
    
    alphaValue.z = alphaValue.x > 0 ? 1 : 0;
    Result01[id.xy] = alphaValue;
}

[numthreads(8, 8, 1)]
void ThreeLayersBlend (uint3 id : SV_DispatchThreadID)
{
    float4 secondLayerValueD = _TextureInput01[id.xy];
    float4 secondLayerValueT = _TextureInput02[id.xy];
    float4 thirdLayerValueT = _TextureInput03[id.xy];
    float4 alphaLayerValue = _TextureInput04[id.xy];
      
    float4 threeAreaAlpha = 0;
    uint3 texID = 0;
    if (secondLayerValueD.a != 0)
    {
        texID = uint3(id.xy, Decode(secondLayerValueD.x));
        threeAreaAlpha.x = _AlphaTextureArray[texID];
    }
    if (secondLayerValueT.a != 0)
    {
        texID = uint3(id.xy, Decode(secondLayerValueT.x));
        threeAreaAlpha.y = _AlphaTextureArray[texID];
    }
    if (thirdLayerValueT.a != 0)
    {
        texID = uint3(id.xy, Decode(thirdLayerValueT.x));
        threeAreaAlpha.z = _AlphaTextureArray[texID];
    }
    if (alphaLayerValue.a != 0)
    {
        texID = uint3(id.xy, Decode(alphaLayerValue.x));
        threeAreaAlpha.w = _AlphaTextureArray[texID];
    }
    Result01[id.xy] = threeAreaAlpha;
}